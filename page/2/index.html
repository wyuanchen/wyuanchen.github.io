<!DOCTYPE html>
<html>

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
	<meta name="theme-color" content="#33474d">
	<title>wYuan&#39;s Blog</title>
	<link rel="stylesheet" href="/css/style.css" />
	
</head>

<body>

	<header class="header">
		<nav class="header__nav">
			
				<a href="/archives" class="header__link">Archive</a>
			
				<a href="/tags" class="header__link">Tags</a>
			
				<a href="/categories" class="header__link">Categories</a>
			
		</nav>
		<h1 class="header__title"><a href="/">wYuan&#39;s Blog</a></h1>
		<h2 class="header__subtitle">Enjoy the world</h2>
	</header>

	<main>
		
	<span class="different-posts different-posts_earlier">📖 <a href="/">earlier posts</a> 📖</span>




	<article>
	
		<h1><a href="/2017/01/27/前端使用FormData实现上传文件/">前端使用FormData实现上传文件</a></h1>
	
	<div class="article__infos">
		<span class="article__date">2017-01-27</span><br />
		
			<span class="article__category">
				<a class="article-category-link" href="/categories/前端/">前端</a>
			</span><br />
		
		
			<span class="article__tags">
			  	<a class="article__tag-link" href="/tags/js/">js</a> <a class="article__tag-link" href="/tags/前端/">前端</a>
			</span>
		
	</div>

	

	
		<blockquote>
<p>场景: 用户通过点击图片弹出上传文件的框框，然后选择将要替换的图片，选择后实时预览，点击确定后通过ajax上传到服务器.</p>
</blockquote>
<p><strong>前端html</strong><br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"img_div"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">id</span>=<span class="string">"img_upload"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">id</span>=<span class="string">"picture"</span> <span class="attr">src</span>=<span class="string">"$picturePath$"</span> <span class="attr">alt</span>=<span class="string">"头像"</span> <span class="attr">class</span>=<span class="string">"img-rounded"</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p><strong>将上述html中的上传input元素的透明度设置为0，并且设置宽度和高度，用它来遮住a标签,注意设置外部div的position</strong>   </p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#img_div</span>&#123;</div><div class="line">    <span class="attribute">position</span>: relative;</div><div class="line">&#125;</div><div class="line"><span class="selector-id">#img_upload</span>&#123;</div><div class="line">    <span class="attribute">opacity</span>: <span class="number">0</span>;</div><div class="line">    <span class="attribute">position</span>: absolute;</div><div class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</div><div class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</div><div class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</div><div class="line">    <span class="attribute">z-index</span>: <span class="number">9</span>;</div><div class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
		<p><a class="article__read-more-link" href="/2017/01/27/前端使用FormData实现上传文件/">...read more</a></p>
	

	

</article>




	<article>
	
		<h1><a href="/2016/12/19/ArrayDeque原理学习/">ArrayDeque原理学习</a></h1>
	
	<div class="article__infos">
		<span class="article__date">2016-12-19</span><br />
		
			<span class="article__category">
				<a class="article-category-link" href="/categories/Java/">Java</a>
			</span><br />
		
		
			<span class="article__tags">
			  	<a class="article__tag-link" href="/tags/容器/">容器</a>
			</span>
		
	</div>

	

	
		<ul>
<li><p>Deque接口(双向队列)的两个主要实现类是<code>ArrayDeque</code>和<code>LinkedList</code>       </p>
</li>
<li><p>ArrayDeque底层使用循环数组实现双向队列         </p>
</li>
<li><p>ArrayDeque内部使用的循环数组的容量，当首次进行初始化的时候，最小容量为8，如果超过8，扩大成2的幂            </p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 调用带有容量参数的构造函数后，数组初始化过程</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">allocateElements</span><span class="params">(<span class="keyword">int</span> numElements)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> initialCapacity = MIN_INITIAL_CAPACITY; <span class="comment">// 最小容量为8</span></div><div class="line">    <span class="keyword">if</span> (numElements &gt;= initialCapacity) &#123; <span class="comment">// 如果要分配的容量大于等于8，扩大成2的幂；否则使用最小容量8</span></div><div class="line">        initialCapacity = numElements;</div><div class="line">        initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">1</span>);</div><div class="line">        initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">2</span>);</div><div class="line">        initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">4</span>);</div><div class="line">        initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">8</span>);</div><div class="line">        initialCapacity |= (initialCapacity &gt;&gt;&gt; <span class="number">16</span>);</div><div class="line">        initialCapacity++;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</div><div class="line">            initialCapacity &gt;&gt;&gt;= <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    elements = <span class="keyword">new</span> Object[initialCapacity]; <span class="comment">// 构造数组</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
		<p><a class="article__read-more-link" href="/2016/12/19/ArrayDeque原理学习/">...read more</a></p>
	

	

</article>




	<article>
	
		<h1><a href="/2016/09/13/LinkedHashMap原理学习/">LinkedHashMap原理学习</a></h1>
	
	<div class="article__infos">
		<span class="article__date">2016-09-13</span><br />
		
			<span class="article__category">
				<a class="article-category-link" href="/categories/Java/">Java</a>
			</span><br />
		
		
			<span class="article__tags">
			  	<a class="article__tag-link" href="/tags/容器/">容器</a>
			</span>
		
	</div>

	

	
		<ul>
<li>LinkedHashMap的迭代输出的结果保持了插入顺序。    </li>
<li>LinkedHashMap是Hash表和链表的实现，并且依靠着双向链表保证了迭代顺序是插入的顺序。      </li>
<li><p>根据链表中元素的顺序可以分为：    </p>
<ul>
<li>按插入顺序的链表   </li>
<li><p>按访问顺序(调用 get 方法)的链表。   </p>
<p>默认是按插入顺序排序，如果指定按访问顺序排序，那么调用get方法后，会将这次访问的元素移至链表尾部，不断访问可以形成按访问顺序排序的链表。      </p>
</li>
</ul>
</li>
</ul>
		<p><a class="article__read-more-link" href="/2016/09/13/LinkedHashMap原理学习/">...read more</a></p>
	

	

</article>




	<article>
	
		<h1><a href="/2016/07/25/WebSocket数据编码/">WebSocket数据编码</a></h1>
	
	<div class="article__infos">
		<span class="article__date">2016-07-25</span><br />
		
			<span class="article__category">
				<a class="article-category-link" href="/categories/网络协议/">网络协议</a>
			</span><br />
		
		
			<span class="article__tags">
			  	<a class="article__tag-link" href="/tags/WebSocket/">WebSocket</a>
			</span>
		
	</div>

	

	
		<p>WebSocket传输的数据都是以Frame（帧）的形式实现的，就像TCP/UDP协议中的报文段Segment。下面就是一个Frame：（以bit为单位表示）   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"> 0                   1                   2                   3</div><div class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</div><div class="line">+-+-+-+-+-------+-+-------------+-------------------------------+</div><div class="line">|F|R|R|R| opcode|M| Payload len |    Extended payload length    |</div><div class="line">|I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |</div><div class="line">|N|V|V|V|       |S|             |   (if payload len==126/127)   |</div><div class="line">| |1|2|3|       |K|             |                               |</div><div class="line">+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +</div><div class="line">|     Extended payload length continued, if payload len == 127  |</div><div class="line">+ - - - - - - - - - - - - - - - +-------------------------------+</div><div class="line">|                               |Masking-key, if MASK set to 1  |</div><div class="line">+-------------------------------+-------------------------------+</div><div class="line">| Masking-key (continued)       |          Payload Data         |</div><div class="line">+-------------------------------- - - - - - - - - - - - - - - - +</div><div class="line">:                     Payload Data continued ...                :</div><div class="line">+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +</div><div class="line">|                     Payload Data continued ...                |</div><div class="line">+---------------------------------------------------------------+</div></pre></td></tr></table></figure>
		<p><a class="article__read-more-link" href="/2016/07/25/WebSocket数据编码/">...read more</a></p>
	

	

</article>




	<article>
	
		<h1><a href="/2016/07/18/WebSocket握手/">WebSocket握手</a></h1>
	
	<div class="article__infos">
		<span class="article__date">2016-07-18</span><br />
		
			<span class="article__category">
				<a class="article-category-link" href="/categories/网络协议/">网络协议</a>
			</span><br />
		
		
			<span class="article__tags">
			  	<a class="article__tag-link" href="/tags/WebSocket/">WebSocket</a>
			</span>
		
	</div>

	

	
		<h3 id="WebSocket是基于HTTP协议的，具体建立连接的过程如下："><a href="#WebSocket是基于HTTP协议的，具体建立连接的过程如下：" class="headerlink" title="WebSocket是基于HTTP协议的，具体建立连接的过程如下："></a>WebSocket是基于HTTP协议的，具体建立连接的过程如下：</h3><ol>
<li>TCP三次握手建立一个连接    </li>
<li>发生HTTP协议的握手请求，请求把协议升级为WebSocket       </li>
<li>服务端接收到握手请求后，返回HTTP响应允许协议升级为WebSocket       </li>
<li>客户端和服务端在该连接中以后都用WebSocket协议发生信息和接受信息      </li>
<li>关闭TCP连接    </li>
</ol>
<h3 id="WebSocket握手请求"><a href="#WebSocket握手请求" class="headerlink" title="WebSocket握手请求"></a>WebSocket握手请求</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">GET /chat HTTP/1.1</div><div class="line">Host: server.example.com</div><div class="line">Upgrade: websocket</div><div class="line">Connection: Upgrade</div><div class="line">Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==</div><div class="line">Sec-WebSocket-Protocol: chat, superchat</div><div class="line">Sec-WebSocket-Version: 13</div><div class="line">Origin: http://example.com</div></pre></td></tr></table></figure>
		<p><a class="article__read-more-link" href="/2016/07/18/WebSocket握手/">...read more</a></p>
	

	

</article>




	<article>
	
		<h1><a href="/2016/07/18/WebSocket介绍/">WebSocket介绍</a></h1>
	
	<div class="article__infos">
		<span class="article__date">2016-07-18</span><br />
		
			<span class="article__category">
				<a class="article-category-link" href="/categories/网络协议/">网络协议</a>
			</span><br />
		
		
			<span class="article__tags">
			  	<a class="article__tag-link" href="/tags/WebSocket/">WebSocket</a>
			</span>
		
	</div>

	

	
		<p>首先我们先来看看HTTP这种非持久的协议的一些特点     </p>
<ul>
<li>HTTP的生命周期通过Request来界定，也就是一个Request 一个Response，那么在HTTP1.0中，这次HTTP请求就结束了。   </li>
<li>在HTTP1.1中进行了改进，使得有一个keep-alive，也就是说，在一个HTTP连接中，可以发送多个Request，接收多个Response。     </li>
<li>但是一个request只能有一个response。而且这个response也是被动的，不能主动发起。      </li>
</ul>
		<p><a class="article__read-more-link" href="/2016/07/18/WebSocket介绍/">...read more</a></p>
	

	

</article>




	<article>
	
		<h1><a href="/2016/04/20/事务隔离级别/">事务隔离级别</a></h1>
	
	<div class="article__infos">
		<span class="article__date">2016-04-20</span><br />
		
			<span class="article__category">
				<a class="article-category-link" href="/categories/数据库/">数据库</a>
			</span><br />
		
		
			<span class="article__tags">
			  	<a class="article__tag-link" href="/tags/MySQL/">MySQL</a>
			</span>
		
	</div>

	

	
		<p><img src="http://uploadfiles.nowcoder.com/images/20151114/705973_1447485016662_ACED241801E307EE7A39612F85A94EBF" alt="">   </p>
<ol>
<li><p>更新丢失：   一个事务的更新覆盖了另一个事务的更新。     </p>
</li>
<li><p>脏读：          一个事务读取了另一个事务未提交的数据。    </p>
</li>
<li><p>不可重复读：一个事务两次读取同一个数据，两次读取的数据不一致。    </p>
</li>
<li><p>幻象读：       一个事务两次读取一个范围的记录，两次读取的<strong>记录数</strong>不一致。   </p>
</li>
</ol>
		<p><a class="article__read-more-link" href="/2016/04/20/事务隔离级别/">...read more</a></p>
	

	

</article>




	<article>
	
		<h1><a href="/2016/04/03/where-group-by-having-order-by-顺序/">where, group by, having, order by 顺序</a></h1>
	
	<div class="article__infos">
		<span class="article__date">2016-04-03</span><br />
		
			<span class="article__category">
				<a class="article-category-link" href="/categories/数据库/">数据库</a>
			</span><br />
		
		
			<span class="article__tags">
			  	<a class="article__tag-link" href="/tags/MySQL/">MySQL</a>
			</span>
		
	</div>

	

	
		<h2 id="过滤分组"><a href="#过滤分组" class="headerlink" title="过滤分组"></a>过滤分组</h2><p>对分组过于采用HAVING子句。HAVING子句支持所有WHERE的操作。HAVING与WHERE的区别在于WHERE是过滤行的，而HAVING是用来过滤分组。  </p>
<p>另一种理解WHERE与HAVING的区别的方法是，WHERE在分组之前过滤，而HAVING在分组之后以每组为单位过滤。   </p>
		<p><a class="article__read-more-link" href="/2016/04/03/where-group-by-having-order-by-顺序/">...read more</a></p>
	

	

</article>




	<article>
	
		<h1><a href="/2016/03/17/TCP三次握手和四次挥手/">TCP三次握手和四次挥手</a></h1>
	
	<div class="article__infos">
		<span class="article__date">2016-03-17</span><br />
		
			<span class="article__category">
				<a class="article-category-link" href="/categories/网络协议/">网络协议</a>
			</span><br />
		
		
			<span class="article__tags">
			  	<a class="article__tag-link" href="/tags/TCP/">TCP</a>
			</span>
		
	</div>

	

	
		<p><img src="http://uploadfiles.nowcoder.com/images/20150908/750854_1441709073035_63AE357E551665FD79C9F49FF8BA7E13" alt="">    </p>
		<p><a class="article__read-more-link" href="/2016/03/17/TCP三次握手和四次挥手/">...read more</a></p>
	

	

</article>




	<article>
	
		<h1><a href="/2016/03/15/TCP-UDP区别/">TCP,UDP区别</a></h1>
	
	<div class="article__infos">
		<span class="article__date">2016-03-15</span><br />
		
			<span class="article__category">
				<a class="article-category-link" href="/categories/网络协议/">网络协议</a>
			</span><br />
		
		
			<span class="article__tags">
			  	<a class="article__tag-link" href="/tags/TCP/">TCP</a> <a class="article__tag-link" href="/tags/UDP/">UDP</a>
			</span>
		
	</div>

	

	
		<ul>
<li>UDP协议是<strong>无面向连接</strong>的、<strong>不可靠</strong>的、<strong>无序</strong>的、<strong>无流量控制</strong>的传输层协议，UDP发送的每个数据报是记录型的数据报，所谓的记录型数据报就是接收进程可以识别接收到的数据报的记录边界。  </li>
<li>TCP协议是<strong>面向连接</strong>的、<strong>可靠的</strong>、<strong>有序的</strong>、<strong>拥有流量控制</strong>的传输层协议，它是字节流的协议，无记录边界。  </li>
<li>校验和   <ul>
<li>UDP对首部和数据部分都进行校验，而IP首部的校验和仅对IP的首部进行校验  </li>
<li>TCP的校验和也是对首部和数据部分都进行校验   </li>
<li>UDP的校验和是可选的，而TCP的是必选的。    </li>
</ul>
</li>
</ul>
		<p><a class="article__read-more-link" href="/2016/03/15/TCP-UDP区别/">...read more</a></p>
	

	

</article>





	<span class="different-posts">📖 <a href="/page/3">more posts</a> 📖</span>



	</main>

	<footer class="footer">
	<div class="footer-content">
		
	      <div class="footer__element">
	<p>Hi there, <br />welcome to my Blog glad you found it. Have a look around, will you?</p>
</div>

	    
	      <div class="footer__element">
	<h5>Check out</h5>
	<ul class="footer-links">
		<li class="footer-links__link"><a href="/archives">Archive</a></li>
		
		<li class="footer-links__link"><a href="/about">About</a></li>
		<li class="footer-links__link"><a href="/tags">Tags</a></li>
		<li class="footer-links__link"><a href="/categories">Categories</a></li>
	</ul>
</div>

	    

		<div class="footer-credit">
			<span>© 2017 Wenyuan Chen | Powered by <a href="https://hexo.io/">Hexo</a> | Theme <a href="https://github.com/HoverBaum/meilidu-hexo">MeiliDu</a></span>
		</div>

	</div>


</footer>



</body>

</html>
